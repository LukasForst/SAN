knitr::opts_chunk$set(echo = TRUE)
```{r}
#Load the dataset of 165 words
mydata <- read.csv('data.csv', header = FALSE)
mylabels <- read.csv('labels.txt', header = FALSE)
mycolors <- read.csv('colors.csv', header = FALSE)
PlotPoints(mydata[,c(1,2)], mylabels, mycolors)
```{r include=FALSE, message=FALSE}
PlotPoints <- function(X, labels, colors){
library(deldir, quietly = TRUE)
voronoi <- deldir(X[,1], X[,2])
plot(X[,1], X[,2], type="n", asp=1, xlab = "", ylab = "")
points(X[,1], X[,2], pch=20, col=colors[,1], cex=1.3)
text(X[,1], X[,2], labels = labels[,1], pos = 1, cex = 0.6)
plot(voronoi, wlines="tess", wpoints="none", number=FALSE, add=TRUE, lty=1)
legend("topleft", legend = sort(unique(colors[,1])), col=sort(unique(colors[,1])), pch=20, cex = 0.8)
}
Classify <- function(X, colors, kfolds = 50){
#install.packages('tree')
library(tree)
#library(caret)
set.seed(17)
#add class
if(!any(names(X) == "class")){X <- cbind(X, class=as.factor(colors))}
#randomly shuffle the data
data <-X[sample(nrow(X)),]
#Create 10 equally size folds
folds <- cut(seq(1,nrow(data)),breaks=kfolds,labels=FALSE)
acc <- rep(0, times = kfolds)
#10 fold cross validation
for(i in 1:kfolds){
#Segment your data by fold using the which() function
testIndexes <- which(folds==i,arr.ind=TRUE)
testData <- data[testIndexes, ]
trainData <- data[-testIndexes, ]
model <- tree(formula = class ~., data = trainData)
pre <- predict(model, newdata=testData, y = TRUE, type="class")
acc[i] <- sum(pre == testData$class)/length(testData$class)
}
return(acc)
}
PlotPoints(mydata[,c(1,2)], mylabels, mycolors)
View(mycolors)
View(mydata)
View(mylabels)
View(mycolors)
#ADD YOUR CODE HERE!
#REMOVE eval=FALSE arguments
library('FNN')
library(FNN)
install.packages('FNN')
library(FNN)
get.knn(mudata, k=5)
get.knn(mydata, k=5)
#ADD YOUR CODE HERE!
#REMOVE eval=FALSE arguments
library('FNN')
#ADD YOUR CODE HERE!
#REMOVE eval=FALSE arguments
k <- 5
#1.Determine the neighbors of each point (k-NN)
library('FNN')
get.knn(mydata, k = 5)
length(mydata)
nrows(mydata)
nrow(mydata)
class(mydata)
#1.Determine the neighbors of each point (k-NN)
library('FNN')
k <- 5
knn <- get.knn(mydata, k = k)
class(knn)
class(knn$nn.index)
knn$nn.index
knn$nn.index[1,]
knn$nn.dist[1,]
#2.Construct a neighborhood graph.
#Each point is connected to other if it is a K nearest neighbor.
#Edge length equal to Euclidean distance.
elements <- nrow(mydata)
k <- 5
knn <- get.knn(mydata, k = k)
#2.Construct a neighborhood graph.
#Each point is connected to other if it is a K nearest neighbor.
#Edge length equal to Euclidean distance.
elements <- nrow(mydata)
adjacenncyMatrix <- matrix(0, elements, elements)
for(rowIdx in 1:elements) {
apply(knn$nn.index, 1, function(i) {
adjacenncyMatrix[rowIdx, i] = knn$nn.dist[rowIdx, i]
})
}
for(rowIdx in 1:elements) {
apply(knn$nn.index[rowIdx,], 1, function(i) {
adjacenncyMatrix[rowIdx, i] = knn$nn.dist[rowIdx, i]
})
}
knn$nn.index
knn$nn.index[1,]
class(knn$nn.index[1,])
class(knn$nn.index[1,])
class(knn$nn.index)
for(rowIdx in 1:elements) {
for(neighbor in 1:k) {
adjacenncyMatrix[rowIdx, neighbor] = knn$nn.dist[rowIdx, neighbor]
}
}
install.packages("rfast")
install.packages("Efast")
install.packages("Rfast")
#3.Compute shortest path between two nodes. (Floyd-Warshall algorithm)
library('Rfast')
install.packages('Rfast')
install.packages('Rfast')
knitr::opts_chunk$set(echo = TRUE)
#3.Compute shortest path between two nodes. (Floyd-Warshall algorithm)
library('Rfast')
install.packages('Rfast')
#3.Compute shortest path between two nodes. (Floyd-Warshall algorithm)
library('Rfast')
```{r include=FALSE, message=FALSE}
PlotPoints <- function(X, labels, colors){
library(deldir, quietly = TRUE)
voronoi <- deldir(X[,1], X[,2])
plot(X[,1], X[,2], type="n", asp=1, xlab = "", ylab = "")
points(X[,1], X[,2], pch=20, col=colors[,1], cex=1.3)
text(X[,1], X[,2], labels = labels[,1], pos = 1, cex = 0.6)
plot(voronoi, wlines="tess", wpoints="none", number=FALSE, add=TRUE, lty=1)
legend("topleft", legend = sort(unique(colors[,1])), col=sort(unique(colors[,1])), pch=20, cex = 0.8)
}
Classify <- function(X, colors, kfolds = 50){
#install.packages('tree')
library(tree)
#library(caret)
set.seed(17)
#add class
if(!any(names(X) == "class")){X <- cbind(X, class=as.factor(colors))}
#randomly shuffle the data
data <-X[sample(nrow(X)),]
#Create 10 equally size folds
folds <- cut(seq(1,nrow(data)),breaks=kfolds,labels=FALSE)
acc <- rep(0, times = kfolds)
#10 fold cross validation
for(i in 1:kfolds){
#Segment your data by fold using the which() function
testIndexes <- which(folds==i,arr.ind=TRUE)
testData <- data[testIndexes, ]
trainData <- data[-testIndexes, ]
model <- tree(formula = class ~., data = trainData)
pre <- predict(model, newdata=testData, y = TRUE, type="class")
acc[i] <- sum(pre == testData$class)/length(testData$class)
}
return(acc)
}
#Load the dataset of 165 words
mydata <- read.csv('data.csv', header = FALSE)
mylabels <- read.csv('labels.txt', header = FALSE)
mycolors <- read.csv('colors.csv', header = FALSE)
PlotPoints(mydata[,c(1,2)], mylabels, mycolors)
#1.Determine the neighbors of each point (k-NN)
library('FNN')
k <- 5
knn <- get.knn(mydata, k = k)
#2.Construct a neighborhood graph.
#Each point is connected to other if it is a K nearest neighbor.
#Edge length equal to Euclidean distance.
elements <- nrow(mydata)
adjacenncyMatrix <- matrix(0, elements, elements)
for(rowIdx in 1:elements) {
for(neighbor in 1:k) {
adjacenncyMatrix[rowIdx, neighbor] = knn$nn.dist[rowIdx, neighbor]
}
}
#3.Compute shortest path between two nodes. (Floyd-Warshall algorithm)
library('Rfast')
D <- floyd(adjacencyMatrix)
D <- floyd(adjacencyMatrix)
#3.Compute shortest path between two nodes. (Floyd-Warshall algorithm)
library('Rfast')
D <- floyd(adjacencyMatrix)
D <- floyd(adjacencyMatrix)
adjacencyMatrix <- matrix(0, elements, elements)
for(rowIdx in 1:elements) {
for(neighbor in 1:k) {
adjacencyMatrix[rowIdx, neighbor] = knn$nn.dist[rowIdx, neighbor]
}
}
#3.Compute shortest path between two nodes. (Floyd-Warshall algorithm)
library('Rfast')
D <- floyd(adjacencyMatrix)
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=2)
PlotPoints(fit$points, mylabels, mycolors)
View(D)
View(D)
View(fit)
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=k)
PlotPoints(fit$points, mylabels, mycolors)
View(adjacencyMatrix)
View(adjacencyMatrix)
adjacencyMatrix <- matrix(0, elements, 5)
for(rowIdx in 1:elements) {
for(neighbor in 1:k) {
adjacencyMatrix[rowIdx, neighbor] = knn$nn.dist[rowIdx, neighbor]
}
}
adjacencyMatrix <- matrix(0, elements, elements)
for(rowIdx in 1:elements) {
for(neighbor in 1:k) {
adjacencyMatrix[rowIdx, neighbor] = knn$nn.dist[rowIdx, neighbor]
}
}
for(rowIdx in 1:elements) {
for(i in 1:k) {
neighbor <- knn$nn.index[rowIdx, i]
adjacencyMatrix[rowIdx, neighbor] = knn$nn.dist[rowIdx, neighbor]
}
}
neighbor <- knn$nn.index[rowIdx, i]
for(rowIdx in 1:elements) {
for(i in 1:k) {
neighbor <- knn$nn.index[rowIdx, i]
adjacencyMatrix[rowIdx, neighbor] = knn$nn.dist[rowIdx, i]
}
}
#3.Compute shortest path between two nodes. (Floyd-Warshall algorithm)
library('Rfast')
D <- floyd(adjacencyMatrix)
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=k)
PlotPoints(fit$points, mylabels, mycolors)
#2.Construct a neighborhood graph.
#Each point is connected to other if it is a K nearest neighbor.
#Edge length equal to Euclidean distance.
elements <- nrow(mydata)
for(rowIdx in 1:elements) {
for(i in 1:k) {
adjacencyMatrix[rowIdx, knn$nn.index[rowIdx, i]] = knn$nn.dist[rowIdx, i]
}
}
#3.Compute shortest path between two nodes. (Floyd-Warshall algorithm)
library('Rfast')
D <- floyd(adjacencyMatrix)
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=k)
PlotPoints(fit$points, mylabels, mycolors)
View(D)
View(adjacencyMatrix)
knn$nn.index
for(rowIdx in 1:elements) {
for(i in 1:k) {
adjacencyMatrix[rowIdx, knn$nn.index[rowIdx, i]] <- knn$nn.dist[rowIdx, i]
}
}
D <- floyd(adjacencyMatrix)
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=k)
PlotPoints(fit$points, mylabels, mycolors)
fit$points
```{r}
#Principal component analysis
fitPCA <- prcomp(mydata, center = TRUE, scale. = TRUE)
PlotPoints(fitPCA$x[,c(1,2)], mylabels, mycolors)
#t-SNE (T-Distributed Stochastic Neighbor Embedding)
#install.packages('tsne')
library(tsne)
fittsne <- tsne(mydata, k = 2)
PlotPoints(fittsne, mylabels, mycolors)
fittsne <- tsne(mydata, k = 2)
fittsne <- tsne(mydata, k = 2)
install.packages('tsne')
#t-SNE (T-Distributed Stochastic Neighbor Embedding)
#install.packages('tsne')
library(tsne)
fittsne <- tsne(mydata, k = 2)
fittsne <- tsne(mydata, k = 2)
PlotPoints(fittsne, mylabels, mycolors)
help(matrix)
matrix(0, 2,2)
matrix(0., 2,2)
matrix(0.0, 2,2)
for(rowIdx in 1:elements) {
for(i in 1:k) {
adjacencyMatrix[rowIdx, knn$nn.index[rowIdx, i]] <- knn$nn.dist[rowIdx, i]
adjacencyMatrix[knn$nn.index[rowIdx, i], rowIdx] <- knn$nn.dist[rowIdx, i]
}
}
adjacencyMatrix <- matrix(0, elements, elements)
for(rowIdx in 1:elements) {
for(i in 1:k) {
adjacencyMatrix[rowIdx, knn$nn.index[rowIdx, i]] <- knn$nn.dist[rowIdx, i]
adjacencyMatrix[knn$nn.index[rowIdx, i], rowIdx] <- knn$nn.dist[rowIdx, i]
}
}
D <- floyd(adjacencyMatrix)
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=k)
PlotPoints(fit$points, mylabels, mycolors)
#2.Construct a neighborhood graph.
#Each point is connected to other if it is a K nearest neighbor.
#Edge length equal to Euclidean distance.
elements <- nrow(mydata)
adjacencyMatrix <- matrix(0, elements, elements)
for(rowIdx in 1:elements) {
for(i in 1:k) {
dist <- knn$nn.dist[rowIdx, i]
neighborIdx <- knn$nn.index[rowIdx, i]
adjacencyMatrix[rowIdx, neighborIdx] <- dist
adjacencyMatrix[neighborIdx, rowIdx] <- dist
}
}
D <- floyd(adjacencyMatrix)
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=k)
PlotPoints(fit$points, mylabels, mycolors)
View(D)
View(D)
adjacencyMatrix <- matrix(0, elements, elements)
for(rowIdx in 1:elements) {
for(i in 1:k) {
dist <- knn$nn.dist[rowIdx, i]
neighborIdx <- knn$nn.index[rowIdx, i]
#adjacencyMatrix[rowIdx, neighborIdx] <- dist
adjacencyMatrix[neighborIdx, rowIdx] <- dist
}
}
D <- floyd(adjacencyMatrix)
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=k)
PlotPoints(fit$points, mylabels, mycolors)
View(D)
for(rowIdx in 1:elements) {
for(i in 1:k) {
dist <- knn$nn.dist[rowIdx, i]
neighborIdx <- knn$nn.index[rowIdx, i]
adjacencyMatrix[rowIdx, neighborIdx] <- dist
}
}
D <- floyd(adjacencyMatrix)
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=k)
PlotPoints(fit$points, mylabels, mycolors)
k <- 5
knn <- get.knn(mydata, k = k)
#2.Construct a neighborhood graph.
#Each point is connected to other if it is a K nearest neighbor.
#Edge length equal to Euclidean distance.
elements <- nrow(mydata)
adjacencyMatrix <- matrix(0, elements, elements)
for(rowIdx in 1:elements) {
for(i in 1:k) {
dist <- knn$nn.dist[rowIdx, i]
neighborIdx <- knn$nn.index[rowIdx, i]
adjacencyMatrix[rowIdx, neighborIdx] <- dist
}
}
#3.Compute shortest path between two nodes. (Floyd-Warshall algorithm)
library('Rfast')
D <- floyd(adjacencyMatrix)
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=k)
PlotPoints(fit$points, mylabels, mycolors)
help(floyd)
adjacencyMatrix <- matrix(0, elements, elements)
for(rowIdx in 1:elements) {
for(i in 1:k) {
dist <- knn$nn.dist[rowIdx, i]
neighborIdx <- knn$nn.index[rowIdx, i]
adjacencyMatrix[rowIdx, neighborIdx] <- dist
adjacencyMatrix[neighborIdx, rowIdx] <- dist
}
}
#Load the dataset of 165 words
mydata <- read.csv('data.csv', header = FALSE)
mylabels <- read.csv('labels.txt', header = FALSE)
mycolors <- read.csv('colors.csv', header = FALSE)
```{r include=FALSE, message=FALSE}
PlotPoints <- function(X, labels, colors){
library(deldir, quietly = TRUE)
voronoi <- deldir(X[,1], X[,2])
plot(X[,1], X[,2], type="n", asp=1, xlab = "", ylab = "")
points(X[,1], X[,2], pch=20, col=colors[,1], cex=1.3)
text(X[,1], X[,2], labels = labels[,1], pos = 1, cex = 0.6)
plot(voronoi, wlines="tess", wpoints="none", number=FALSE, add=TRUE, lty=1)
legend("topleft", legend = sort(unique(colors[,1])), col=sort(unique(colors[,1])), pch=20, cex = 0.8)
}
Classify <- function(X, colors, kfolds = 50){
#install.packages('tree')
library(tree)
#library(caret)
set.seed(17)
#add class
if(!any(names(X) == "class")){X <- cbind(X, class=as.factor(colors))}
#randomly shuffle the data
data <-X[sample(nrow(X)),]
#Create 10 equally size folds
folds <- cut(seq(1,nrow(data)),breaks=kfolds,labels=FALSE)
acc <- rep(0, times = kfolds)
#10 fold cross validation
for(i in 1:kfolds){
#Segment your data by fold using the which() function
testIndexes <- which(folds==i,arr.ind=TRUE)
testData <- data[testIndexes, ]
trainData <- data[-testIndexes, ]
model <- tree(formula = class ~., data = trainData)
pre <- predict(model, newdata=testData, y = TRUE, type="class")
acc[i] <- sum(pre == testData$class)/length(testData$class)
}
return(acc)
}
#1.Determine the neighbors of each point (k-NN)
library('FNN')
k <- 5
knn <- get.knn(mydata, k = k)
#2.Construct a neighborhood graph.
#Each point is connected to other if it is a K nearest neighbor.
#Edge length equal to Euclidean distance.
elements <- nrow(mydata)
adjacencyMatrix <- matrix(0, elements, elements)
for(rowIdx in 1:elements) {
for(i in 1:k) {
dist <- knn$nn.dist[rowIdx, i]
neighborIdx <- knn$nn.index[rowIdx, i]
adjacencyMatrix[rowIdx, neighborIdx] <- dist
adjacencyMatrix[neighborIdx, rowIdx] <- dist
}
}
View(adjacencyMatrix)
knn$nn.dist
D <- floyd(adjacencyMatrix)
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=k)
PlotPoints(fit$points, mylabels, mycolors)
knn$nn.index[1,2]
knn$nn.index[1][2]
knn$nn.index[1,][2]
View(fit)
#1.Determine the neighbors of each point (k-NN)
library('FNN')
k <- 5
knn <- get.knn(mydata, k = k)
#2.Construct a neighborhood graph.
#Each point is connected to other if it is a K nearest neighbor.
#Edge length equal to Euclidean distance.
elements <- nrow(mydata)
adjacencyMatrix <- matrix(NA, elements, elements)
for(rowIdx in 1:elements) {
for(i in 1:k) {
dist <- knn$nn.dist[rowIdx, i]
neighborIdx <- knn$nn.index[rowIdx, i]
adjacencyMatrix[rowIdx, neighborIdx] <- dist
adjacencyMatrix[neighborIdx, rowIdx] <- dist
}
}
#3.Compute shortest path between two nodes. (Floyd-Warshall algorithm)
library('Rfast')
D <- floyd(adjacencyMatrix)
#4.(classical) multidimensional scaling
fit <- cmdscale(D,eig=TRUE, k=k)
PlotPoints(fit$points, mylabels, mycolors)
An expected result (for *k* = 5) should look similar (not necessarily exactly the same) to following
![Example output](graph_iso.pdf)
