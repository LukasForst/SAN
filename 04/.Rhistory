knitr::opts_chunk$set(echo = TRUE)
```{r}
#Load the dataset of 165 words
mydata <- read.csv('data.csv', header = FALSE)
mylabels <- read.csv('labels.txt', header = FALSE)
mycolors <- read.csv('colors.csv', header = FALSE)
PlotPoints(mydata[,c(1,2)], mylabels, mycolors)
```{r include=FALSE, message=FALSE}
PlotPoints <- function(X, labels, colors){
library(deldir, quietly = TRUE)
voronoi <- deldir(X[,1], X[,2])
plot(X[,1], X[,2], type="n", asp=1, xlab = "", ylab = "")
points(X[,1], X[,2], pch=20, col=colors[,1], cex=1.3)
text(X[,1], X[,2], labels = labels[,1], pos = 1, cex = 0.6)
plot(voronoi, wlines="tess", wpoints="none", number=FALSE, add=TRUE, lty=1)
legend("topleft", legend = sort(unique(colors[,1])), col=sort(unique(colors[,1])), pch=20, cex = 0.8)
}
Classify <- function(X, colors, kfolds = 50){
#install.packages('tree')
library(tree)
#library(caret)
set.seed(17)
#add class
if(!any(names(X) == "class")){X <- cbind(X, class=as.factor(colors))}
#randomly shuffle the data
data <-X[sample(nrow(X)),]
#Create 10 equally size folds
folds <- cut(seq(1,nrow(data)),breaks=kfolds,labels=FALSE)
acc <- rep(0, times = kfolds)
#10 fold cross validation
for(i in 1:kfolds){
#Segment your data by fold using the which() function
testIndexes <- which(folds==i,arr.ind=TRUE)
testData <- data[testIndexes, ]
trainData <- data[-testIndexes, ]
model <- tree(formula = class ~., data = trainData)
pre <- predict(model, newdata=testData, y = TRUE, type="class")
acc[i] <- sum(pre == testData$class)/length(testData$class)
}
return(acc)
}
PlotPoints(mydata[,c(1,2)], mylabels, mycolors)
View(mycolors)
View(mydata)
View(mylabels)
View(mycolors)
#ADD YOUR CODE HERE!
#REMOVE eval=FALSE arguments
library('FNN')
library(FNN)
install.packages('FNN')
library(FNN)
get.knn(mudata, k=5)
get.knn(mydata, k=5)
#ADD YOUR CODE HERE!
#REMOVE eval=FALSE arguments
library('FNN')
#ADD YOUR CODE HERE!
#REMOVE eval=FALSE arguments
k <- 5
#1.Determine the neighbors of each point (k-NN)
library('FNN')
get.knn(mydata, k = 5)
length(mydata)
nrows(mydata)
nrow(mydata)
class(mydata)
#1.Determine the neighbors of each point (k-NN)
library('FNN')
k <- 5
knn <- get.knn(mydata, k = k)
class(knn)
class(knn$nn.index)
knn$nn.index
knn$nn.index[1,]
knn$nn.dist[1,]
#2.Construct a neighborhood graph.
#Each point is connected to other if it is a K nearest neighbor.
#Edge length equal to Euclidean distance.
elements <- nrow(mydata)
k <- 5
knn <- get.knn(mydata, k = k)
#2.Construct a neighborhood graph.
#Each point is connected to other if it is a K nearest neighbor.
#Edge length equal to Euclidean distance.
elements <- nrow(mydata)
adjacenncyMatrix <- matrix(0, elements, elements)
for(rowIdx in 1:elements) {
apply(knn$nn.index, 1, function(i) {
adjacenncyMatrix[rowIdx, i] = knn$nn.dist[rowIdx, i]
})
}
for(rowIdx in 1:elements) {
apply(knn$nn.index[rowIdx,], 1, function(i) {
adjacenncyMatrix[rowIdx, i] = knn$nn.dist[rowIdx, i]
})
}
knn$nn.index
knn$nn.index[1,]
class(knn$nn.index[1,])
class(knn$nn.index[1,])
class(knn$nn.index)
for(rowIdx in 1:elements) {
for(neighbor in 1:k) {
adjacenncyMatrix[rowIdx, neighbor] = knn$nn.dist[rowIdx, neighbor]
}
}
install.packages("rfast")
install.packages("Efast")
install.packages("Rfast")
#3.Compute shortest path between two nodes. (Floyd-Warshall algorithm)
library('Rfast')
install.packages('Rfast')
install.packages('Rfast')
